#include <stdint.h>
#include "stm32l1xx.h"

// PIN ASSIGNMENTS
// PB6 UPPER LEFT GATE 
// PB7 UPPER RIGHT GATE
// PA8 LOWER LEFT GATE
// PA9 LOWER RIGHT GATE

// FWD
// PB6&PA9

// REV
// PB7&PA8


#define SHOOT 1000000
#define LLS 8
#define RLS 9
#define REVL ((ARV/100)*DCYC)

void sysclk_Configure(void);
void io_Configure(void);
void pb_Configure(void);
void timer4_Configure(void);
void adc_Configure(void);
void motor_Stop(void);
void motor_Forward(void);
void motor_Reverse(void);

int DIR, ARV, DCYC;

int main(void)
{
	/* MOTOR DRIVER PROPERTIES */
	
	int FREQ;
	// DESIRED PWM FREQUENCY
	FREQ = 20000;
	// DESIRED PWM DUTY CYCLE
	DCYC = 0;
	// CALCULATED AUTO RELOAD VALUE FOR TIM4
	ARV = 16000000/FREQ;
	// DESIRED DIRECTION (1 FORWARD, 0 STOP, -1 REVERSE)
	DIR = 0;
	
	
	/* SYSTEM CLOCK CONFIGURE */
	sysclk_Configure();
		
	/* I/O CONFIGURATION */
	io_Configure();
	
	/* PUSH BUTTON INTERRUPT CONFIGURE */
	pb_Configure();
	
	/* TIMER 4 CONFIGURATION */
	timer4_Configure();
	
	/* ADC CONFIGURATION */
	adc_Configure();
	
	motor_Stop();
	
	while(1);
}

void EXTI0_IRQHandler(void) {
	switch (DIR) {
		case -1:
			motor_Forward();
			break;
		case 0:
			motor_Reverse();
			break;
		case 1:
			motor_Reverse();
			break;
	}
	// CLEAR INTERRUPT
	EXTI->PR |= EXTI_PR_PR0;
}

void ADC1_IRQHandler (void){
	int CCR, OR, AND, XOR;
	// CHECK FOR END OF CONVERSION
	if ((ADC1->SR & ADC_SR_EOC) != 0){
		// CLEAR EOC BIT
		ADC1->SR &= ~ADC_SR_EOC;
		// RESET INTERRUPT ENABLE
		ADC1->CR1 |= ADC_CR1_EOCIE;
		// CLEAR EOC AGAIN?
		ADC1->SR &= ~ADC_SR_EOC;
		
		// NORMALLY THIS IS PID CONTROLLER
		// BUT FOR NOW A POT IS USED
		// TO CONTROL DUTY CYCLE
		DCYC = ((ADC1->DR *100)/0xFFF);
		
	}
	// START CONVERSIONS AGAIN
	ADC1->CR2 |= ADC_CR2_SWSTART;
	
	// UPDATE TIMER WITH NEW DUTY CYCLE
	switch (DIR) {
		case 1 :
			CCR = TIM4->CCR1 &= TIM_CCR1_CCR1;
			AND = CCR & REVL;
			OR = CCR | REVL;
			XOR = AND ^ OR;
			TIM4->CCR1 ^= XOR;
			break;
		case -1:
			CCR = TIM4->CCR2 &= TIM_CCR2_CCR2;
			AND = CCR & REVL;
			OR = CCR | REVL;
			XOR = AND ^ OR;
			TIM4->CCR2 ^= XOR;
	}
			
}

	
	/* SYSTEM CLOCK CONFIGURE */
void sysclk_Configure(void){
	
	// ENABLE HSI
	RCC->CR |= RCC_CR_HSION;
	
	// WAIT FOR HSI
	while ((RCC->CR & RCC_CR_HSIRDY) == 0);
	
//	// CONFIGURE PLL CLOCK TO ACHIEVE 32MHZ SYSTEM CLOCK
//	RCC->CFGR |= RCC_CFGR_PLLSRC_HSI;
//	RCC->CFGR |= RCC_CFGR_PLLMUL6;
//	RCC->CFGR |= RCC_CFGR_PLLDIV3;
//	
//	// ENABLE PLL CLOCK
//	RCC->CR |= RCC_CR_PLLON;
//	while ((RCC->CR & RCC_CR_PLLRDY) == 0);
//	
//	// SELECT PLL AS SYSTEM CLOCK
//	RCC->CFGR &= ~RCC_CFGR_SW;
//	RCC->CFGR |= RCC_CFGR_SW_PLL;
//	
//	// WAIT FOR PLL TO BE SELECTED
//	while ((RCC->CFGR & RCC_CFGR_SWS) == !RCC_CFGR_SWS_PLL);

	// SELECT HSI AS SYSTEM CLOCK
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_HSI;
	
	// WAIT FOR HSI TO BE SELECTED
	while ((RCC->CFGR & RCC_CFGR_SWS) == !RCC_CFGR_SWS_HSI);
}
	
	/* I/O CONFIGURATION */
void io_Configure(void) {
	// ENABLE GPIO A CLOCK
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
	// ENABLE GPIO B CLOCK
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
	// ENABLE GPIO C CLOCK
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
	
//	// CONFIGURE PA0 AS INPUT (RESET STATE)
//	GPIOA->MODER |= ~GPIO_MODER_MODER0;
	
	// CONFIGURE PA8&9 AS OUPUTS
	GPIOA->MODER |= GPIO_MODER_MODER8_0;
	GPIOA->MODER |= GPIO_MODER_MODER9_0;
	
	// CONFIGURE PB4&5 AS NO PULL UP NO PULL DOWN
	
	
	// PREPARE INITIAL MOTOR PROPERTIES
	GPIOA->ODR |= (0<<LLS | 0<<RLS);
	
	// CONFIGURE PB6 AS ALTERNATE FUNCTION MODE
	GPIOB->MODER |= GPIO_MODER_MODER6_1;
	
	// CONFIGURE PB7 AS ALTERNATE FUNCTION MODE
	GPIOB->MODER |= GPIO_MODER_MODER7_1;
	
	// SELECT ALTERNATE FUNCTION TIM4 CHANNEL 1 FOR PB6
	GPIOB->AFR[0] |= (0X02 << (4*6));
	
	// SELECT ALTERNATE FUNCTION TIM 4 CHANNEL 2 FOR PB7
	GPIOB->AFR[0] |= (0X02 << (4*7));
	
	// CONFIGURE PC0 AS ANALOG
	GPIOC->MODER |= GPIO_MODER_MODER0;
}

	/* PUSH BUTTON INTERRUPT CONFIGURE */
void pb_Configure(void) {
	// UNMASK INTERRUPT FOR EXTI 0, PUSH BUTTON
	EXTI->IMR |= EXTI_IMR_MR0;
	// SET INTERRUPT FOR RISING EDGE
	EXTI->RTSR |= EXTI_RTSR_TR0;
	// ENABLE PUSH BUTTON INTERRUPT
	NVIC->ISER[0] |= NVIC_ISER_SETENA_6;
	
	// SET INTERRUPT PRIORITY
	NVIC->IP[6] |= (NVIC_IPR0_PRI_0 & 1);
}
	
	/* TIMER 4 CONFIGURATION */
void timer4_Configure(void){
	
	// ENABLE TIMER 4 CLOCK
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
	
	// TIMER 4 PRESCALER BASED OFF 16MHZ HSI
	TIM4->PSC |= 0;
	
	// AUTO RELOAD REGISTER
	TIM4->ARR &= ~TIM_ARR_ARR;
	TIM4->ARR |= ARV;
	
	// CONFIGURE PWM MODE TO MODE 1 CHANNEL 1
	TIM4->CCMR1 &= ~(TIM_CCMR1_OC1M);
	TIM4->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1);
	
	// CONFIGURE PWM MODE TO MODE 1 CHANNEL 2
	TIM4->CCMR1 &= ~(TIM_CCMR1_OC2M);
	TIM4->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1);
	
	// ENABLE AUTO RELAOD
	TIM4->CR1 |= TIM_CR1_ARPE;
	
	// ENABLE CHANNEL 1 OUTPUT
	TIM4->CCER |= TIM_CCER_CC1E;
	
	// ENABLE CHANNEL 2 OUTPUT
	TIM4->CCER |= TIM_CCER_CC2E;
	
	// PRELOAD CAPTURE COMPARE VALUE FOR CHANNEL 1
	TIM4->CCR1 |= 0;
	
	// PRELOAD CAPTURE COMPARE VALUE FOR CHANNEL 2
	TIM4->CCR2 |= 0;
	
	//ENABLE TIMER
	TIM4->CR1 |= TIM_CR1_CEN;
	
}	
	
	/* ADC CONFIGURATION */
void adc_Configure(void){
	// ENABLE ADC
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
	
	// DISABLE CONVERSION
	ADC1->CR2 &= ~ADC_CR2_ADON;
	
	// CONFIGURE REGULAR CHANNEL SEQUENCE LENGTH TO 1 CONVERSION
	ADC1->SQR1 &= ~ADC_SQR1_L;
	
	// SELECT CHANNEL 10 AS FIRST AND ONLY CONVERSION
	ADC1->SQR5 |= 0xA;
	
	// SELECT 16 CYCLES PER SAMPLE FOR CONVERSION
	ADC1->SMPR2 |= 0x2;
	
////	// ENABLE ANALOG WATCHDOG
////	ADC1->CR1 |- ADC_CR1_AWDEN;
////	
////	// ENABLE ANALOG WATCHDOG INTERRUPT
////	ADC1->CR1 |= ADC_CR1_AWDIE;
////	
////	// SELECT CHANNEL 10 FOR WATCH DOG
////	ADC1->CR1 |= 0xA;

	// ENABLE END OF CONVERSION INTERRUPT
	ADC1->CR1 |= ADC_CR1_EOCIE;
	
	// ENABLE CONTINUOUS CONVERSION
	ADC1->CR2 |= ADC_CR2_CONT;
	
	// ENABLE ADC INTERRUPT
	NVIC->ISER[0] |= NVIC_ISER_SETENA_18;
	
	// SET INTERRUPT PRIORITY
	NVIC->IP[18] |= (NVIC_IPR0_PRI_0 & 1);
	
	// ENABLE ADC
	ADC1->CR2 |= ADC_CR2_ADON;
	
	// BEGIN CONVERSIONS
	ADC1->CR2 |= ADC_CR2_SWSTART;
}

void motor_Stop(void) {
	int i;
	// SET MOTOR DIRECTION TO 0
	DIR = 0;
	// CANCEL BOTH PWM SIGNALS
	TIM4->CCR1 &= 0;
	TIM4->CCR2 &= 0;
	// OPEN (DISABLE) BOTH LOW SIDE GATES
	GPIOA->ODR &= (1<<LLS);
	GPIOA->ODR &= (1<<RLS);
	// DEAD TIME TO PREVENT SHOOT THROUGH
	for (i=0; i<SHOOT; i++);
}

void motor_Forward(void){
	// STOP MOTOR TO PREPARE FOR DIRECTION CHANGE
	motor_Stop();
	
	//CONFIGURE LOW SIDE GATES
	GPIOA->ODR |= (GPIOA->ODR &= ~(1<<LLS));
	GPIOA->ODR |= (1<<RLS);

	
	// CONFIGURE PWM SIGNAL
	TIM4->CCR1 = REVL;
	
	// CHANGE DIRECTION VALUE
	DIR = 1;	
}

void motor_Reverse(void){
	// STOP MOTOR TO PREPARE FOR DIRECTION CHANGE
	motor_Stop();
	
	//CONFIGURE LOW SIDE GATES
	GPIOA->ODR |= (GPIOA->ODR &= ~(1<<RLS));
	GPIOA->ODR |= (1<<LLS);
	
	// CONFIGURE PWM SIGNAL
	TIM4->CCR2 = REVL;
	
	// CHANGE DIRECTION VALUE
	DIR = -1;	
}

